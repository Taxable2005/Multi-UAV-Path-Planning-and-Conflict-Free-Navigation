clc
clear all
close all

%% Setup Drone
m = 0.2
I = [[0.1,0,0];[0,0.1,0];[0,0,0.08]]

% sample time
ts = 0.01

% Initial States (Initial XYZ is generated by XYZsignal script)
Euler_0 = [0 0;
           0 0;
           0 0]

% XYZ_0 should not be [0;0;0] because the initial target point is set to
% [0;0;0]
XYZ_0 = [0.1 10.1;
         0.1 10.1;
         0.1 10.1]

XYZ_1 = [10.1  0.1;
         10.1  0.1;
         10.1  0.1];

body_rate_0 = [0 0;
               0 0;
               0 0]

% Set surround rate (if 0: follow mode; if 0.5: surround mode)
surround_rate = 0

% Environment
g = [0;0;-9.8]

dX1 = []      
dY1 = []
dZ1 = []

dX2 = []      
dY2 = []
dZ2 = []


XYZ_obst = [5;5;10];

r = 2;
priority = [1,2]


t = linspace(1,20.5,100)
s = linspace(0,1,length(t));
Circle1 = trajactory(XYZ_1(:,1),XYZ_0(:,1),XYZ_obst,r)

a =1:100

x = XYZ_0(1,2) + s'*(XYZ_1(1,2)-XYZ_0(1,2));
y = XYZ_0(2,2) + s'*(XYZ_1(2,2)-XYZ_0(2,2));
z = XYZ_0(3,2) + s'*(XYZ_1(3,2)-XYZ_0(3,2));


F2 = (x-Circle1(1,:)').^2 + (y-Circle1(2,:)').^2 + (z-Circle1(3,:)').^2 - r^2;
idx2 = F2 <= 0;
idx_start = find(idx2, 1, 'first');
% Effective sphere center (initially follows Drone 1)
centre_fixed = Circle1(:,idx_start)

F2_org = (x-centre_fixed(1)).^2 + (y-centre_fixed(2)).^2 + (z-centre_fixed(3)).^2 - r^2;
idx_org = F2_org <= 0

idx_org_start = find(idx_org, 1, 'first');
idx_org_end   = find(idx_org, 1, 'last');
N_arc     = idx_org_end - idx_org_start + 1;

p_entry = [x(idx_org_start); y(idx_org_start); z(idx_org_start)];
p_exit  = [x(idx_org_end);   y(idx_org_end);   z(idx_org_end)];

v1 = XYZ_1(:,2) - XYZ_0(:,2);
v2 = XYZ_obst - XYZ_0(:,2);

n  = cross(v1, v2);
n  = n / norm(n);

u1 = v1 / norm(v1);
u2 = cross(n, u1);
u2 = u2 / norm(u2);



theta_entry = atan2( dot(p_entry - centre_fixed, u2), ...
                      dot(p_entry - centre_fixed, u1) );

theta_exit  = atan2( dot(p_exit  - centre_fixed, u2), ...
                      dot(p_exit  - centre_fixed, u1) );

theta = linspace(theta_entry, theta_exit, N_arc);



x(idx_org_start:idx_org_end) = centre_fixed(1) + r * ...
    (u1(1)*cos(theta) + u2(1)*sin(theta));

y(idx_org_start:idx_org_end) = centre_fixed(2) + r * ...
    (u1(2)*cos(theta) + u2(2)*sin(theta));

z(idx_org_start:idx_org_end) = centre_fixed(3) + r * ...
    (u1(3)*cos(theta) + u2(3)*sin(theta));












%% ================= WAYPOINTS = XYZ()kdsdk================
Waypoints1 = [Circle1(1,:)' Circle1(2,:)' Circle1(3,:)' t'];
Waypoints2 = [x y z t'];



WayPts1 = [Circle1(1,:)' Circle1(2,:)' Circle1(3,:)' t'];
WayPts2 = [XYZ_0(1,2) XYZ_0(2,2) XYZ_0(3,2) 0;
           Waypoints2];

for i = 1:length(WayPts1)-1
    % Drone 1
    dX1(i) = (WayPts1(i+1,1)-WayPts1(i,1))/(WayPts1(i+1,4)-WayPts1(i,4));
    dY1(i) = (WayPts1(i+1,2)-WayPts1(i,2))/(WayPts1(i+1,4)-WayPts1(i,4));
    dZ1(i) = (WayPts1(i+1,3)-WayPts1(i,3))/(WayPts1(i+1,4)-WayPts1(i,4));
    

end

for i = 1:length(WayPts2)-1
    % Drone 2
    dX2(i) = (WayPts2(i+1,1)-WayPts2(i,1))/(WayPts2(i+1,4)-WayPts2(i,4));
    dY2(i) = (WayPts2(i+1,2)-WayPts2(i,2))/(WayPts2(i+1,4)-WayPts2(i,4));
    dZ2(i) = (WayPts2(i+1,3)-WayPts2(i,3))/(WayPts2(i+1,4)-WayPts2(i,4));
end

Tfinal1 = WayPts1(end,4);   % last time of Drone 1
Tfinal2 = WayPts2(end,4);   % last time of Drone 2
Tfinal = max(Tfinal1, Tfinal2) + 10;  % add extra buffer to hold final positions

TOFtime = 1
tss = 0.1 
t = 0:tss:Tfinal


% Superpose signals
x_sum1 = 0*t
z_sum1 = 0*t
y_sum1 = 0*t

x_sum2 = 0*t
z_sum2 = 0*t
y_sum2 = 0*t

x0 = WayPts2(1,1);
y0 = WayPts2(1,2);
z0 = WayPts2(1,3);


for k = 1:length(WayPts1)
    if k == 1 % time: 0-1 sec, 1st Waypts
        section1 = [0, WayPts1(k,4)];
        start_section1 = section1(1);
        end_section1 = section1(2);
        
        for i = 1:length(z_sum1)
            if t(i) >= start_section1 && t(i) <= end_section1
                z_sum1(i) = 0;
                y_sum1(i) = 0;
                x_sum1(i) = 0;
            end
        end
        
    elseif k == 2 % time: 1-2 sec, 2nd Waypts, take-off process
        section1 = [WayPts1(k-1,4),WayPts1(k,4)]
        start_section1 = section1(1);
        end_section1 = section1(2);
        
        for i = 1:length(z_sum1)
            if t(i) > start_section1 && t(i) <= end_section1
                z_sum1(i) = WayPts1(k,3);
                y_sum1(i) = 0;
                x_sum1(i) = 0;
            end
        end
        
    else % time: 2 - last Waypts sec, free fly mode
        section1 = [WayPts1(k-1,4),WayPts1(k,4)]
        start_section1 = section1(1);
        end_section1 = section1(2);
        
        for i = 1:length(z_sum1)            
            if t(i) > start_section1 && t(i) <= end_section1
                z_sum1(i) = z_sum1(i-1) + tss*dZ1(k-2);
                y_sum1(i) = y_sum1(i-1) + tss*dY1(k-2);
                x_sum1(i) = x_sum1(i-1) + tss*dX1(k-2);
            end
        end
        
    end
end


for k = 1:length(WayPts2)
    if k == 1 % time: 0-1 sec, 1st Waypts
        section2 = [0, WayPts2(k,4)];
        start_section2 = section2(1);
        end_section2 = section2(2);
        
        for i = 1:length(z_sum2)
            if t(i) >= start_section2 && t(i) <= end_section2
                z_sum2(i) = 0;
                y_sum2(i) = 0;
                x_sum2(i) = 0;
            end
        end
        
    elseif k == 2 % time: 1-2 sec, 2nd Waypts, take-off process
        section2 = [WayPts2(k-1,4),WayPts2(k,4)]
        start_section2 = section2(1);
        end_section2 = section2(2);
        
        for i = 1:length(z_sum2)
            if t(i) > start_section2 && t(i) <= end_section2
                z_sum2(i) = WayPts2(k,3);
                y_sum2(i) = 0;
                x_sum2(i) = 0;
            end
        end
        
    else % time: 2 - last Waypts sec, free fly mode
        section2 = [WayPts2(k-1,4),WayPts2(k,4)]
        start_section2 = section2(1);
        end_section2 = section2(2);
        
        for i = 1:length(z_sum2)            
            if t(i) > start_section2 && t(i) <= end_section2
                z_sum2(i) = z_sum2(i-1) + tss*dZ2(k-2);
                y_sum2(i) = y_sum2(i-1) + tss*dY2(k-2);
                x_sum2(i) = x_sum2(i-1) + tss*dX2(k-2);
            end
        end
        
    end
end

start_section1 = WayPts1(length(WayPts1),4)
end_section1 = Tfinal
for i = 1:length(z_sum1)
    if t(i) > start_section1 && t(i) <= end_section1
        z_sum1(i) = z_sum1(i-1)
        y_sum1(i) = y_sum1(i-1)
        x_sum1(i) = x_sum1(i-1)
    end
end

start_section2 = WayPts2(length(WayPts2),4)
end_section2 = Tfinal
for i = 1:length(z_sum2)
    if t(i) > start_section2 && t(i) <= end_section2
        z_sum2(i) = z_sum2(i-1)
        y_sum2(i) = y_sum2(i-1)
        x_sum2(i) = x_sum2(i-1)
    end
end

% Generate timeseries cmd
sigZ1 = [t;z_sum1]
Zcmd1 = timeseries(sigZ1(2:end,:),sigZ1(1,:))
sigY1 = [t;y_sum1]
Ycmd1 = timeseries(sigY1(2:end,:),sigY1(1,:))
sigX1 = [t;x_sum1]
Xcmd1 = timeseries(sigX1(2:end,:),sigX1(1,:))

% Generate timeseries cmd
sigZ2 = [t;z_sum2]
Zcmd2 = timeseries(sigZ2(2:end,:),sigZ2(1,:))
sigY2 = [t;y_sum2]
Ycmd2 = timeseries(sigY2(2:end,:),sigY2(1,:))
sigX2 = [t;x_sum2]
Xcmd2 = timeseries(sigX2(2:end,:),sigX2(1,:))








clear section1
clear start_section1
clear end_section1
clear y_sum1
clear z_sum1
clear x_sum1
clear section2
clear start_section2
clear end_section2
clear y_sum2
clear z_sum2
clear x_sum2
clear i
clear k



clear Circle1
clear F2
clear F2_org
clear idx2
clear idx2_org
clear SphereC
clear Waypoints1
clear Waypoints2
clear theta_idx
figure
hold on
grid on
axis equal
view(3)

% ================= Drone 1 =================
% Start and End points
scatter3(XYZ_0(1,1), XYZ_0(2,1), XYZ_0(3,1), ...
         100, 'g', 'filled')
scatter3(XYZ_1(1,1), XYZ_1(2,1), XYZ_1(3,1), ...
         100, 'r', 'filled')

% Waypoints trajectory
plot3(WayPts1(:,1), WayPts1(:,2), WayPts1(:,3), ...
      'b', 'LineWidth', 2)

% ================= Drone 2 =================
% Start and End points
scatter3(XYZ_0(1,2), XYZ_0(2,2), XYZ_0(3,2), ...
         100, 'c', 'filled')
scatter3(XYZ_1(1,2), XYZ_1(2,2), XYZ_1(3,2), ...
         100, 'm', 'filled')

% Waypoints trajectory
plot3(WayPts2(:,1), WayPts2(:,2), WayPts2(:,3), ...
      'k', 'LineWidth', 2)

% ================= Labels & Legend =================
xlabel('X')
ylabel('Y')
zlabel('Z')

legend( ...
    'Drone 1 Start (XYZ\_0)', ...
    'Drone 1 End (XYZ\_1)', ...
    'Drone 1 Waypoints', ...
    'Drone 2 Start (XYZ\_0)', ...
    'Drone 2 End (XYZ\_1)', ...
    'Drone 2 Waypoints', ...
    'Location', 'best')

title('3D Trajectory Visualization of Both Drones')

function DrawPlaneThrough3Points(XYZ_0, XYZ_1, XYZ_obst)
    % XYZ_0, XYZ_1, XYZ_obst: 3x1 column vectors
    % Draw a plane passing through the three points
    
    % Vectors in the plane
    v1 = XYZ_1 - XYZ_0;
    v2 = XYZ_obst - XYZ_0;
    
    % Create parameter grid
    [s, t] = meshgrid(linspace(0,1,10), linspace(0,1,10));
    
    % Parametric plane points
    X = XYZ_0(1) + v1(1)*s + v2(1)*t;
    Y = XYZ_0(2) + v1(2)*s + v2(2)*t;
    Z = XYZ_0(3) + v1(3)*s + v2(3)*t;
    
    % Plot the plane
    surf(X, Y, Z, 'FaceAlpha', 0.5, 'EdgeColor', 'none', 'FaceColor', [0 0 1]);
    hold on
    
    % Plot the three points
    scatter3([XYZ_0(1), XYZ_1(1), XYZ_obst(1)], ...
             [XYZ_0(2), XYZ_1(2), XYZ_obst(2)], ...
             [XYZ_0(3), XYZ_1(3), XYZ_obst(3)], 100, 'filled', 'r');
    
    xlabel('X'); ylabel('Y'); zlabel('Z');
    grid on; axis equal;
    figure

end

function Circle = trajactory(XYZ_1,XYZ_0,XYZ_obst,r)

%forming a plane with XYZ_0 XYZ_1 and XYZ_obst
v1 = XYZ_1 - XYZ_0;
v2 = XYZ_obst - XYZ_0;
n = cross(v1, v2);   % n = [A; B; C]
n = n / norm(n);
%Creating another coordinate system in that plane with u and v and making
%circle using u and v
u1 = v1 / norm(v1);
u2 = cross(n, u1);
u2 = u2 / norm(u2);



t = linspace(0,1,100)



%Intersection point of line and circle
f = XYZ_0 - XYZ_obst;
d = XYZ_1 - XYZ_0;
a = dot(d,d);
b = 2*dot(d,f);
c = dot(f,f) - r^2;
t_vals = roots([a b c]);
t1 = min(t_vals);
t2 = max(t_vals);
XYZ_exit = XYZ_0 + (XYZ_1 - XYZ_0)*t2;
XYZ_entry = XYZ_0 + (XYZ_1 - XYZ_0)*t1;

if(isreal(XYZ_entry) && isreal(XYZ_exit))
theta_entry = atan2(dot(XYZ_entry - XYZ_obst, u2), dot(XYZ_entry - XYZ_obst, u1));
theta_exit  = atan2(dot(XYZ_exit - XYZ_obst,  u2), dot(XYZ_exit - XYZ_obst,  u1));

idx = (t >= t1) & (t <= t2);

theta_idx = theta_entry + ...
            (theta_exit - theta_entry) * ...
            (t(idx) - t1) / (t2 - t1);

theta = theta_entry + (theta_exit - theta_entry) * ((t(idx) - t1) / (t2 - t1));
Circle(:,~idx) = XYZ_0 + (XYZ_1 - XYZ_0)*t(~idx);
Circle(:,idx) = XYZ_obst + r * ( u1 * cos(theta) + u2 * sin(theta) );

else

Circle = XYZ_0 + (XYZ_1 - XYZ_0)*t

end
end

function Waypoints_final = speed_control(waypoints1 , waypoints2,priority)
xyz1=[waypoints1(:,1) waypoints1(:,2) waypoints1(:,3)]
xyz2=[waypoints2(:,1) waypoints2(:,2) waypoints2(:,3)]

diff = xyz1 - xyz2;   
d_safe = 1.0;                       % safety distance
dist_sq = sum(diff.^2, 2);     
conflict_idx = dist_sq < d_safe^2;  % logical array

idx = find(conflict_idx);

if isempty(idx)
    offset = 0;   % no conflict
    Waypoints_final = waypoints2;
else
offset = idx(end)-idx(1) + 25 %+1 is done for safety prospective

if (priority == [1,2])
    t_new = waypoints2(:,4);
    t_new(idx(1):end) = t_new(idx(1):end) + offset;
    waypoints2(:,4) = t_new;
    Waypoints_final = waypoints2;
else
    t_new = waypoints1(:,4);
    t_new(idx(1):end) = t_new(idx(1):end) + offset;
    waypoints1(:,4) = t_new;
    Waypoints_final = waypoints1;
end
end
end
